// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: network.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Particle_Ctrl_NetworkState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case networkStatusNone // = 0
  case down // = 1
  case up // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .networkStatusNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .networkStatusNone
    case 1: self = .down
    case 2: self = .up
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .networkStatusNone: return 0
    case .down: return 1
    case .up: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Particle_Ctrl_NetworkState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Particle_Ctrl_NetworkState] = [
    .networkStatusNone,
    .down,
    .up,
  ]
}

#endif  // swift(>=4.2)

/// Direct mapping to if_flags_t
enum Particle_Ctrl_InterfaceFlag: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case iffNone // = 0
  case iffUp // = 1
  case iffBroadcast // = 2
  case iffDebug // = 4
  case iffLoopback // = 8
  case iffPointtopoint // = 16
  case iffRunning // = 64
  static let iffLowerUp = iffRunning
  case iffNoarp // = 128
  case iffPromisc // = 256
  case iffAllmulti // = 512
  case iffMulticast // = 32768
  case iffNond6 // = 65536
  case UNRECOGNIZED(Int)

  init() {
    self = .iffNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .iffNone
    case 1: self = .iffUp
    case 2: self = .iffBroadcast
    case 4: self = .iffDebug
    case 8: self = .iffLoopback
    case 16: self = .iffPointtopoint
    case 64: self = .iffRunning
    case 128: self = .iffNoarp
    case 256: self = .iffPromisc
    case 512: self = .iffAllmulti
    case 32768: self = .iffMulticast
    case 65536: self = .iffNond6
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .iffNone: return 0
    case .iffUp: return 1
    case .iffBroadcast: return 2
    case .iffDebug: return 4
    case .iffLoopback: return 8
    case .iffPointtopoint: return 16
    case .iffRunning: return 64
    case .iffNoarp: return 128
    case .iffPromisc: return 256
    case .iffAllmulti: return 512
    case .iffMulticast: return 32768
    case .iffNond6: return 65536
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Particle_Ctrl_InterfaceFlag: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Particle_Ctrl_InterfaceFlag] = [
    .iffNone,
    .iffUp,
    .iffBroadcast,
    .iffDebug,
    .iffLoopback,
    .iffPointtopoint,
    .iffRunning,
    .iffNoarp,
    .iffPromisc,
    .iffAllmulti,
    .iffMulticast,
    .iffNond6,
  ]
}

#endif  // swift(>=4.2)

/// Direct mapping to if_xflags_t
enum Particle_Ctrl_InterfaceExtFlag: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ifxfNone // = 0
  case ifxfWol // = 16
  case ifxfAutoconf6 // = 32
  case ifxfDhcp // = 65536
  case ifxfDhcp6 // = 131072
  case ifxfAutoip // = 262144
  case UNRECOGNIZED(Int)

  init() {
    self = .ifxfNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ifxfNone
    case 16: self = .ifxfWol
    case 32: self = .ifxfAutoconf6
    case 65536: self = .ifxfDhcp
    case 131072: self = .ifxfDhcp6
    case 262144: self = .ifxfAutoip
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ifxfNone: return 0
    case .ifxfWol: return 16
    case .ifxfAutoconf6: return 32
    case .ifxfDhcp: return 65536
    case .ifxfDhcp6: return 131072
    case .ifxfAutoip: return 262144
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Particle_Ctrl_InterfaceExtFlag: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Particle_Ctrl_InterfaceExtFlag] = [
    .ifxfNone,
    .ifxfWol,
    .ifxfAutoconf6,
    .ifxfDhcp,
    .ifxfDhcp6,
    .ifxfAutoip,
  ]
}

#endif  // swift(>=4.2)

enum Particle_Ctrl_InterfaceType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case invalidInterfaceType // = 0
  case loopback // = 1
  case thread // = 2
  case ethernet // = 4
  case wifi // = 8
  case ppp // = 16
  case UNRECOGNIZED(Int)

  init() {
    self = .invalidInterfaceType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalidInterfaceType
    case 1: self = .loopback
    case 2: self = .thread
    case 4: self = .ethernet
    case 8: self = .wifi
    case 16: self = .ppp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .invalidInterfaceType: return 0
    case .loopback: return 1
    case .thread: return 2
    case .ethernet: return 4
    case .wifi: return 8
    case .ppp: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Particle_Ctrl_InterfaceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Particle_Ctrl_InterfaceType] = [
    .invalidInterfaceType,
    .loopback,
    .thread,
    .ethernet,
    .wifi,
    .ppp,
  ]
}

#endif  // swift(>=4.2)

struct Particle_Ctrl_NetworkGetStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var interface: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_NetworkGetStatusReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var config: Particle_Ctrl_NetworkConfiguration {
    get {return _storage._config ?? Particle_Ctrl_NetworkConfiguration()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {_uniqueStorage()._config = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Particle_Ctrl_NetworkGetConfigurationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var interface: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_NetworkGetConfigurationReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var config: Particle_Ctrl_NetworkConfiguration {
    get {return _storage._config ?? Particle_Ctrl_NetworkConfiguration()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {_uniqueStorage()._config = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Particle_Ctrl_NetworkSetConfigurationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var config: Particle_Ctrl_NetworkConfiguration {
    get {return _storage._config ?? Particle_Ctrl_NetworkConfiguration()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {_uniqueStorage()._config = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Particle_Ctrl_NetworkSetConfigurationReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_IPConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Particle_Ctrl_IPConfiguration.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var address: Particle_Ctrl_IPAddress {
    get {return _storage._address ?? Particle_Ctrl_IPAddress()}
    set {_uniqueStorage()._address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return _storage._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {_uniqueStorage()._address = nil}

  var netmask: Particle_Ctrl_IPAddress {
    get {return _storage._netmask ?? Particle_Ctrl_IPAddress()}
    set {_uniqueStorage()._netmask = newValue}
  }
  /// Returns true if `netmask` has been explicitly set.
  var hasNetmask: Bool {return _storage._netmask != nil}
  /// Clears the value of `netmask`. Subsequent reads from it will return its default value.
  mutating func clearNetmask() {_uniqueStorage()._netmask = nil}

  var gateway: Particle_Ctrl_IPAddress {
    get {return _storage._gateway ?? Particle_Ctrl_IPAddress()}
    set {_uniqueStorage()._gateway = newValue}
  }
  /// Returns true if `gateway` has been explicitly set.
  var hasGateway: Bool {return _storage._gateway != nil}
  /// Clears the value of `gateway`. Subsequent reads from it will return its default value.
  mutating func clearGateway() {_uniqueStorage()._gateway = nil}

  var dhcpServer: Particle_Ctrl_IPAddress {
    get {return _storage._dhcpServer ?? Particle_Ctrl_IPAddress()}
    set {_uniqueStorage()._dhcpServer = newValue}
  }
  /// Returns true if `dhcpServer` has been explicitly set.
  var hasDhcpServer: Bool {return _storage._dhcpServer != nil}
  /// Clears the value of `dhcpServer`. Subsequent reads from it will return its default value.
  mutating func clearDhcpServer() {_uniqueStorage()._dhcpServer = nil}

  var hostname: String {
    get {return _storage._hostname}
    set {_uniqueStorage()._hostname = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case dhcp // = 1
    case `static` // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .dhcp
      case 2: self = .static
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .dhcp: return 1
      case .static: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Particle_Ctrl_IPConfiguration.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Particle_Ctrl_IPConfiguration.TypeEnum] = [
    .none,
    .dhcp,
    .static,
  ]
}

#endif  // swift(>=4.2)

struct Particle_Ctrl_DNSConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var servers: [Particle_Ctrl_IPAddress] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_NetworkConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var interface: Int32 {
    get {return _storage._interface}
    set {_uniqueStorage()._interface = newValue}
  }

  var state: Particle_Ctrl_NetworkState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var mac: Data {
    get {return _storage._mac}
    set {_uniqueStorage()._mac = newValue}
  }

  var ipconfig: Particle_Ctrl_IPConfiguration {
    get {return _storage._ipconfig ?? Particle_Ctrl_IPConfiguration()}
    set {_uniqueStorage()._ipconfig = newValue}
  }
  /// Returns true if `ipconfig` has been explicitly set.
  var hasIpconfig: Bool {return _storage._ipconfig != nil}
  /// Clears the value of `ipconfig`. Subsequent reads from it will return its default value.
  mutating func clearIpconfig() {_uniqueStorage()._ipconfig = nil}

  var dnsconfig: Particle_Ctrl_DNSConfiguration {
    get {return _storage._dnsconfig ?? Particle_Ctrl_DNSConfiguration()}
    set {_uniqueStorage()._dnsconfig = newValue}
  }
  /// Returns true if `dnsconfig` has been explicitly set.
  var hasDnsconfig: Bool {return _storage._dnsconfig != nil}
  /// Clears the value of `dnsconfig`. Subsequent reads from it will return its default value.
  mutating func clearDnsconfig() {_uniqueStorage()._dnsconfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Particle_Ctrl_Ipv4Address {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_Ipv6Address {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_IpAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: OneOf_Address? {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  var v4: Particle_Ctrl_Ipv4Address {
    get {
      if case .v4(let v)? = _storage._address {return v}
      return Particle_Ctrl_Ipv4Address()
    }
    set {_uniqueStorage()._address = .v4(newValue)}
  }

  var v6: Particle_Ctrl_Ipv6Address {
    get {
      if case .v6(let v)? = _storage._address {return v}
      return Particle_Ctrl_Ipv6Address()
    }
    set {_uniqueStorage()._address = .v6(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Address: Equatable {
    case v4(Particle_Ctrl_Ipv4Address)
    case v6(Particle_Ctrl_Ipv6Address)

  #if !swift(>=4.1)
    static func ==(lhs: Particle_Ctrl_IpAddress.OneOf_Address, rhs: Particle_Ctrl_IpAddress.OneOf_Address) -> Bool {
      switch (lhs, rhs) {
      case (.v4(let l), .v4(let r)): return l == r
      case (.v6(let l), .v6(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Particle_Ctrl_InterfaceAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: Particle_Ctrl_IpAddress {
    get {return _storage._address ?? Particle_Ctrl_IpAddress()}
    set {_uniqueStorage()._address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return _storage._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {_uniqueStorage()._address = nil}

  /// TODO: state, scope, lifetimes, etc.
  var prefixLength: UInt32 {
    get {return _storage._prefixLength}
    set {_uniqueStorage()._prefixLength = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Particle_Ctrl_Ipv4Config {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addresses: [Particle_Ctrl_InterfaceAddress] {
    get {return _storage._addresses}
    set {_uniqueStorage()._addresses = newValue}
  }

  /// On P2P links
  var peer: Particle_Ctrl_Ipv4Address {
    get {return _storage._peer ?? Particle_Ctrl_Ipv4Address()}
    set {_uniqueStorage()._peer = newValue}
  }
  /// Returns true if `peer` has been explicitly set.
  var hasPeer: Bool {return _storage._peer != nil}
  /// Clears the value of `peer`. Subsequent reads from it will return its default value.
  mutating func clearPeer() {_uniqueStorage()._peer = nil}

  /// Temporary, will be moved to routing table
  var gateway: Particle_Ctrl_Ipv4Address {
    get {return _storage._gateway ?? Particle_Ctrl_Ipv4Address()}
    set {_uniqueStorage()._gateway = newValue}
  }
  /// Returns true if `gateway` has been explicitly set.
  var hasGateway: Bool {return _storage._gateway != nil}
  /// Clears the value of `gateway`. Subsequent reads from it will return its default value.
  mutating func clearGateway() {_uniqueStorage()._gateway = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Particle_Ctrl_Ipv6Config {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addresses: [Particle_Ctrl_InterfaceAddress] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Operation state of the interface
struct Particle_Ctrl_Interface {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var index: UInt32 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var type: Particle_Ctrl_InterfaceType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// InterfaceFlag
  var flags: UInt32 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  /// InterfaceExtFlag
  var extFlags: UInt32 {
    get {return _storage._extFlags}
    set {_uniqueStorage()._extFlags = newValue}
  }

  var ipv4Config: Particle_Ctrl_Ipv4Config {
    get {return _storage._ipv4Config ?? Particle_Ctrl_Ipv4Config()}
    set {_uniqueStorage()._ipv4Config = newValue}
  }
  /// Returns true if `ipv4Config` has been explicitly set.
  var hasIpv4Config: Bool {return _storage._ipv4Config != nil}
  /// Clears the value of `ipv4Config`. Subsequent reads from it will return its default value.
  mutating func clearIpv4Config() {_uniqueStorage()._ipv4Config = nil}

  var ipv6Config: Particle_Ctrl_Ipv6Config {
    get {return _storage._ipv6Config ?? Particle_Ctrl_Ipv6Config()}
    set {_uniqueStorage()._ipv6Config = newValue}
  }
  /// Returns true if `ipv6Config` has been explicitly set.
  var hasIpv6Config: Bool {return _storage._ipv6Config != nil}
  /// Clears the value of `ipv6Config`. Subsequent reads from it will return its default value.
  mutating func clearIpv6Config() {_uniqueStorage()._ipv6Config = nil}

  var hwAddress: Data {
    get {return _storage._hwAddress}
    set {_uniqueStorage()._hwAddress = newValue}
  }

  var mtu: UInt32 {
    get {return _storage._mtu}
    set {_uniqueStorage()._mtu = newValue}
  }

  var metric: UInt32 {
    get {return _storage._metric}
    set {_uniqueStorage()._metric = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Particle_Ctrl_InterfaceEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var index: UInt32 = 0

  var name: String = String()

  var type: Particle_Ctrl_InterfaceType = .invalidInterfaceType

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_GetInterfaceListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_GetInterfaceListReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var interfaces: [Particle_Ctrl_InterfaceEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_GetInterfaceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var index: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_GetInterfaceReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var interface: Particle_Ctrl_Interface {
    get {return _storage._interface ?? Particle_Ctrl_Interface()}
    set {_uniqueStorage()._interface = newValue}
  }
  /// Returns true if `interface` has been explicitly set.
  var hasInterface: Bool {return _storage._interface != nil}
  /// Clears the value of `interface`. Subsequent reads from it will return its default value.
  mutating func clearInterface() {_uniqueStorage()._interface = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "particle.ctrl"

extension Particle_Ctrl_NetworkState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NETWORK_STATUS_NONE"),
    1: .same(proto: "DOWN"),
    2: .same(proto: "UP"),
  ]
}

extension Particle_Ctrl_InterfaceFlag: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IFF_NONE"),
    1: .same(proto: "IFF_UP"),
    2: .same(proto: "IFF_BROADCAST"),
    4: .same(proto: "IFF_DEBUG"),
    8: .same(proto: "IFF_LOOPBACK"),
    16: .same(proto: "IFF_POINTTOPOINT"),
    64: .aliased(proto: "IFF_RUNNING", aliases: ["IFF_LOWER_UP"]),
    128: .same(proto: "IFF_NOARP"),
    256: .same(proto: "IFF_PROMISC"),
    512: .same(proto: "IFF_ALLMULTI"),
    32768: .same(proto: "IFF_MULTICAST"),
    65536: .same(proto: "IFF_NOND6"),
  ]
}

extension Particle_Ctrl_InterfaceExtFlag: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IFXF_NONE"),
    16: .same(proto: "IFXF_WOL"),
    32: .same(proto: "IFXF_AUTOCONF6"),
    65536: .same(proto: "IFXF_DHCP"),
    131072: .same(proto: "IFXF_DHCP6"),
    262144: .same(proto: "IFXF_AUTOIP"),
  ]
}

extension Particle_Ctrl_InterfaceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_INTERFACE_TYPE"),
    1: .same(proto: "LOOPBACK"),
    2: .same(proto: "THREAD"),
    4: .same(proto: "ETHERNET"),
    8: .same(proto: "WIFI"),
    16: .same(proto: "PPP"),
  ]
}

extension Particle_Ctrl_NetworkGetStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkGetStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interface"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.interface)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.interface != 0 {
      try visitor.visitSingularInt32Field(value: self.interface, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_NetworkGetStatusRequest, rhs: Particle_Ctrl_NetworkGetStatusRequest) -> Bool {
    if lhs.interface != rhs.interface {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_NetworkGetStatusReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkGetStatusReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
  ]

  fileprivate class _StorageClass {
    var _config: Particle_Ctrl_NetworkConfiguration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _config = source._config
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._config)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_NetworkGetStatusReply, rhs: Particle_Ctrl_NetworkGetStatusReply) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._config != rhs_storage._config {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_NetworkGetConfigurationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkGetConfigurationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interface"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.interface)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.interface != 0 {
      try visitor.visitSingularInt32Field(value: self.interface, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_NetworkGetConfigurationRequest, rhs: Particle_Ctrl_NetworkGetConfigurationRequest) -> Bool {
    if lhs.interface != rhs.interface {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_NetworkGetConfigurationReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkGetConfigurationReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
  ]

  fileprivate class _StorageClass {
    var _config: Particle_Ctrl_NetworkConfiguration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _config = source._config
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._config)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_NetworkGetConfigurationReply, rhs: Particle_Ctrl_NetworkGetConfigurationReply) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._config != rhs_storage._config {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_NetworkSetConfigurationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkSetConfigurationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
  ]

  fileprivate class _StorageClass {
    var _config: Particle_Ctrl_NetworkConfiguration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _config = source._config
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._config)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_NetworkSetConfigurationRequest, rhs: Particle_Ctrl_NetworkSetConfigurationRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._config != rhs_storage._config {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_NetworkSetConfigurationReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkSetConfigurationReply"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_NetworkSetConfigurationReply, rhs: Particle_Ctrl_NetworkSetConfigurationReply) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_IPConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IPConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "address"),
    3: .same(proto: "netmask"),
    4: .same(proto: "gateway"),
    5: .standard(proto: "dhcp_server"),
    6: .same(proto: "hostname"),
  ]

  fileprivate class _StorageClass {
    var _type: Particle_Ctrl_IPConfiguration.TypeEnum = .none
    var _address: Particle_Ctrl_IPAddress? = nil
    var _netmask: Particle_Ctrl_IPAddress? = nil
    var _gateway: Particle_Ctrl_IPAddress? = nil
    var _dhcpServer: Particle_Ctrl_IPAddress? = nil
    var _hostname: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _address = source._address
      _netmask = source._netmask
      _gateway = source._gateway
      _dhcpServer = source._dhcpServer
      _hostname = source._hostname
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._address)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._netmask)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._gateway)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._dhcpServer)
        case 6: try decoder.decodeSingularStringField(value: &_storage._hostname)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .none {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if let v = _storage._address {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._netmask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._gateway {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._dhcpServer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._hostname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostname, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_IPConfiguration, rhs: Particle_Ctrl_IPConfiguration) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._netmask != rhs_storage._netmask {return false}
        if _storage._gateway != rhs_storage._gateway {return false}
        if _storage._dhcpServer != rhs_storage._dhcpServer {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_IPConfiguration.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "DHCP"),
    2: .same(proto: "STATIC"),
  ]
}

extension Particle_Ctrl_DNSConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DNSConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "servers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.servers)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.servers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.servers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_DNSConfiguration, rhs: Particle_Ctrl_DNSConfiguration) -> Bool {
    if lhs.servers != rhs.servers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_NetworkConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interface"),
    2: .same(proto: "state"),
    3: .same(proto: "name"),
    4: .same(proto: "mac"),
    5: .same(proto: "ipconfig"),
    6: .same(proto: "dnsconfig"),
  ]

  fileprivate class _StorageClass {
    var _interface: Int32 = 0
    var _state: Particle_Ctrl_NetworkState = .networkStatusNone
    var _name: String = String()
    var _mac: Data = SwiftProtobuf.Internal.emptyData
    var _ipconfig: Particle_Ctrl_IPConfiguration? = nil
    var _dnsconfig: Particle_Ctrl_DNSConfiguration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _interface = source._interface
      _state = source._state
      _name = source._name
      _mac = source._mac
      _ipconfig = source._ipconfig
      _dnsconfig = source._dnsconfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._interface)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._state)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._mac)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._ipconfig)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._dnsconfig)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._interface != 0 {
        try visitor.visitSingularInt32Field(value: _storage._interface, fieldNumber: 1)
      }
      if _storage._state != .networkStatusNone {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._mac.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._mac, fieldNumber: 4)
      }
      if let v = _storage._ipconfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._dnsconfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_NetworkConfiguration, rhs: Particle_Ctrl_NetworkConfiguration) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._interface != rhs_storage._interface {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._mac != rhs_storage._mac {return false}
        if _storage._ipconfig != rhs_storage._ipconfig {return false}
        if _storage._dnsconfig != rhs_storage._dnsconfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_Ipv4Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ipv4Address"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFixed32Field(value: &self.address)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularFixed32Field(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_Ipv4Address, rhs: Particle_Ctrl_Ipv4Address) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_Ipv6Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ipv6Address"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_Ipv6Address, rhs: Particle_Ctrl_Ipv6Address) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_IpAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IpAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v4"),
    2: .same(proto: "v6"),
  ]

  fileprivate class _StorageClass {
    var _address: Particle_Ctrl_IpAddress.OneOf_Address?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Particle_Ctrl_Ipv4Address?
          if let current = _storage._address {
            try decoder.handleConflictingOneOf()
            if case .v4(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._address = .v4(v)}
        case 2:
          var v: Particle_Ctrl_Ipv6Address?
          if let current = _storage._address {
            try decoder.handleConflictingOneOf()
            if case .v6(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._address = .v6(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._address {
      case .v4(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .v6(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_IpAddress, rhs: Particle_Ctrl_IpAddress) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_InterfaceAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InterfaceAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "prefix_length"),
  ]

  fileprivate class _StorageClass {
    var _address: Particle_Ctrl_IpAddress? = nil
    var _prefixLength: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _prefixLength = source._prefixLength
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._address)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._prefixLength)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._address {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._prefixLength != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._prefixLength, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_InterfaceAddress, rhs: Particle_Ctrl_InterfaceAddress) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._prefixLength != rhs_storage._prefixLength {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_Ipv4Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ipv4Config"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addresses"),
    2: .same(proto: "peer"),
    3: .same(proto: "gateway"),
  ]

  fileprivate class _StorageClass {
    var _addresses: [Particle_Ctrl_InterfaceAddress] = []
    var _peer: Particle_Ctrl_Ipv4Address? = nil
    var _gateway: Particle_Ctrl_Ipv4Address? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _addresses = source._addresses
      _peer = source._peer
      _gateway = source._gateway
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._addresses)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._peer)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._gateway)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._addresses.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._addresses, fieldNumber: 1)
      }
      if let v = _storage._peer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._gateway {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_Ipv4Config, rhs: Particle_Ctrl_Ipv4Config) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._addresses != rhs_storage._addresses {return false}
        if _storage._peer != rhs_storage._peer {return false}
        if _storage._gateway != rhs_storage._gateway {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_Ipv6Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ipv6Config"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addresses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.addresses)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_Ipv6Config, rhs: Particle_Ctrl_Ipv6Config) -> Bool {
    if lhs.addresses != rhs.addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_Interface: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Interface"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "name"),
    3: .same(proto: "type"),
    4: .same(proto: "flags"),
    5: .standard(proto: "ext_flags"),
    6: .standard(proto: "ipv4_config"),
    7: .standard(proto: "ipv6_config"),
    8: .standard(proto: "hw_address"),
    9: .same(proto: "mtu"),
    10: .same(proto: "metric"),
  ]

  fileprivate class _StorageClass {
    var _index: UInt32 = 0
    var _name: String = String()
    var _type: Particle_Ctrl_InterfaceType = .invalidInterfaceType
    var _flags: UInt32 = 0
    var _extFlags: UInt32 = 0
    var _ipv4Config: Particle_Ctrl_Ipv4Config? = nil
    var _ipv6Config: Particle_Ctrl_Ipv6Config? = nil
    var _hwAddress: Data = SwiftProtobuf.Internal.emptyData
    var _mtu: UInt32 = 0
    var _metric: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _index = source._index
      _name = source._name
      _type = source._type
      _flags = source._flags
      _extFlags = source._extFlags
      _ipv4Config = source._ipv4Config
      _ipv6Config = source._ipv6Config
      _hwAddress = source._hwAddress
      _mtu = source._mtu
      _metric = source._metric
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._index)
        case 2: try decoder.decodeSingularStringField(value: &_storage._name)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._flags)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._extFlags)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._ipv4Config)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._ipv6Config)
        case 8: try decoder.decodeSingularBytesField(value: &_storage._hwAddress)
        case 9: try decoder.decodeSingularUInt32Field(value: &_storage._mtu)
        case 10: try decoder.decodeSingularUInt32Field(value: &_storage._metric)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._index != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._index, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if _storage._type != .invalidInterfaceType {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 3)
      }
      if _storage._flags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._flags, fieldNumber: 4)
      }
      if _storage._extFlags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._extFlags, fieldNumber: 5)
      }
      if let v = _storage._ipv4Config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._ipv6Config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._hwAddress.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._hwAddress, fieldNumber: 8)
      }
      if _storage._mtu != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._mtu, fieldNumber: 9)
      }
      if _storage._metric != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._metric, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_Interface, rhs: Particle_Ctrl_Interface) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._index != rhs_storage._index {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._extFlags != rhs_storage._extFlags {return false}
        if _storage._ipv4Config != rhs_storage._ipv4Config {return false}
        if _storage._ipv6Config != rhs_storage._ipv6Config {return false}
        if _storage._hwAddress != rhs_storage._hwAddress {return false}
        if _storage._mtu != rhs_storage._mtu {return false}
        if _storage._metric != rhs_storage._metric {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_InterfaceEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InterfaceEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "name"),
    3: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.index)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.type != .invalidInterfaceType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_InterfaceEntry, rhs: Particle_Ctrl_InterfaceEntry) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_GetInterfaceListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInterfaceListRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_GetInterfaceListRequest, rhs: Particle_Ctrl_GetInterfaceListRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_GetInterfaceListReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInterfaceListReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interfaces"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.interfaces)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.interfaces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.interfaces, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_GetInterfaceListReply, rhs: Particle_Ctrl_GetInterfaceListReply) -> Bool {
    if lhs.interfaces != rhs.interfaces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_GetInterfaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInterfaceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.index)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_GetInterfaceRequest, rhs: Particle_Ctrl_GetInterfaceRequest) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_GetInterfaceReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInterfaceReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interface"),
  ]

  fileprivate class _StorageClass {
    var _interface: Particle_Ctrl_Interface? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _interface = source._interface
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._interface)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._interface {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_GetInterfaceReply, rhs: Particle_Ctrl_GetInterfaceReply) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._interface != rhs_storage._interface {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
